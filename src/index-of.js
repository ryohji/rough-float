/**
 * NaN => -128
 * [-Infinity,              -(2 ** ( 63/6 - 1/12))) => -127
 * [-(2 ** ( 62/6 + 1/12)), -(2 ** ( 62/6 - 1/12))) => -126
 * [-(2 ** ( 61/6 + 1/12)), -(2 ** ( 61/6 - 1/12))) => -125
 * ...
 * [-(2 ** (  1/6 + 1/12)), -(2 ** (  1/6 - 1/12))) => -65
 * [-(2 ** (  0/6 + 1/12)), -(2 ** (  0/6 - 1/12))) => -64
 * [-(2 ** (- 1/6 + 1/12)), -(2 ** (- 1/6 - 1/12))) => -63
 * ...
 * [-(2 ** (-62/6 + 1/12)), -(2 ** (-62/6 - 1/12))) => -2
 * [-(2 ** (-63/6 + 1/12)), -(2 ** (-63/6 - 1/12))) => -1
 * [-(2 ** (-64/6 + 1/12)),  (2 ** (-64/6 + 1/12))) => 0
 * [ (2 ** (-63/6 - 1/12)),  (2 ** (-63/6 + 1/12))) => 1
 * [ (2 ** (-62/6 - 1/12)),  (2 ** (-62/6 + 1/12))) => 2
 * ...
 * [ (2 ** (- 1/6 - 1/12)),  (2 ** (- 1/6 + 1/12))) =>  63
 * [ (2 ** (  0/6 - 1/12)),  (2 ** (  0/6 + 1/12))) =>  64
 * [ (2 ** (  1/6 - 1/12)),  (2 ** (  1/6 + 1/12))) =>  65
 * ...
 * [ (2 ** ( 61/6 - 1/12)),  (2 ** ( 61/6 + 1/12))) =>  125
 * [ (2 ** ( 62/6 - 1/12)),  (2 ** ( 62/6 + 1/12))) =>  126
 * [ (2 ** ( 63/6 - 1/12)),  Infinity             ) =>  127
 */
const ts = [];
for (let i = 0; i < 127; ++i) {
    ts.push(-Math.pow(2, (125 - i * 2)/12));
}
for (let i = 0; i < 127; ++i) {
    ts.push(Math.pow(2, (-127 + i * 2)/12));
}
export const indexOf = x => {
    if (Number.isNaN(x)) {
        return -128;
    } else {
        const i = ts.findIndex(t => x < t);
        return i > -1 ? i - 127 : 127;
    }
};
